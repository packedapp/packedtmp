package internal.app.packed.invoke;

import static java.lang.constant.ConstantDescs.CD_Class;
import static java.lang.constant.ConstantDescs.CD_MethodHandles;
import static java.lang.constant.ConstantDescs.CD_MethodHandles_Lookup;

import java.lang.classfile.ClassFile;
import java.lang.constant.ClassDesc;
import java.lang.constant.MethodTypeDesc;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.reflect.AccessFlag;
import java.util.Collections;
import java.util.Map;
import java.util.UUID;
import java.util.WeakHashMap;

import app.packed.extension.Extension; // The class we verify against

/**
 * A privileged accessor that acquires a {@link java.lang.invoke.MethodHandles.Lookup} with
 * {@link java.lang.invoke.MethodHandles.Lookup#MODULE MODULE} access for foreign modules.
 *
 * <p>
 * This class enables the framework to perform deep reflection, modify final fields, and generate hidden classes within
 * client modules that have {@code open} packages to the framework.
 *
 * <h2>The "Hidden Class" Catch-22</h2>
 * <p>
 * Standard approaches to acquiring {@code MODULE} access typically involve injecting a <em>Hidden Class</em> into the
 * target module. However, this creates a circular dependency validation failure:
 * <ol>
 * <li>To inject code into a foreign module, we must first obtain a {@code Lookup} via
 * {@link java.lang.invoke.MethodHandles#privateLookupIn(Class, java.lang.invoke.MethodHandles.Lookup)}.</li>
 * <li>By design, {@code privateLookupIn} <strong>drops</strong> the {@code MODULE} access bit, granting only
 * {@code PRIVATE} and {@code PACKAGE} access (even if the package is open).</li>
 * <li>The method
 * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, java.lang.invoke.MethodHandles.Lookup.ClassOption...)}
 * <strong>requires</strong> {@code MODULE} access (specifically "Full Privilege Access").</li>
 * </ol>
 * <p>
 * Thus, we cannot define a hidden class to get module access because we lack the module access required to define a
 * hidden class.
 *
 * <h2>The Solution: The "Handshake Spy"</h2>
 * <p>
 * To bypass this limitation, this class utilizes {@link java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])},
 * which requires only {@code PACKAGE} access (which we possess). This creates a standard, named class within the target
 * module.
 *
 * <p>
 * Because named classes are discoverable via {@link Class#forName(String)} (unlike hidden classes), simply exposing a
 * {@code public static Lookup get()} method would be a critical security vulnerability; any malicious actor in the
 * module could find the class and escalate their privileges.
 *
 * <h2>Security Model</h2>
 * <p>
 * To secure the generated named class, we implement a <strong> Handshake</strong> pattern directly in the generated
 * bytecode:
 *
 * <ul>
 * <li><strong>Identity Verification:</strong> The generated class exposes a method:
 * {@code public static Lookup get(Lookup token)}.</li>
 * <li><strong>Caller Validation:</strong> The bytecode inspects the provided {@code lookup token}. It extracts the
 * module of the token's lookup class and compares it against the immutable identity of this framework's module
 * (anchored to {@value #FRAMEWORK_ANCHOR}</li>
 * <li><strong>Reference Equality:</strong> The check uses {@code if_acmpne} (reference equality) to ensure the module
 * identity cannot be spoofed by string names.</li>
 * <li><strong>Unforgeable Token:</strong> Only code residing strictly within the {@code app.packed} module can produce
 * a {@code Lookup} object that satisfies this check.</li>
 * </ul>
 *
 * <p>
 * If an attacker discovers the class name and calls the method, they cannot produce a valid lookup originating from
 * this module, and the method throws a {@link SecurityException}.
 */
final class ModuleAccessor {

    /** This module. */
    private static final Module THIS_MODULE = ModuleAccessor.class.getModule();

    /**
     * The generated bytecode will call {@code Extension.class.getModule()} to assert that the caller belongs to this
     * module.
     */
    private static final Class<?> FRAMEWORK_CLASS = Extension.class;

    /**
     * A weak hashmap cache of a lookup objects with full privilege for a given module. This cache acts as L2 cache. with
     * {@link #PER_CLASS_CACHE} being the L1 cache.
     */
    private static final Map<Module, Lookup> PER_MODULE_CACHE = Collections.synchronizedMap(new WeakHashMap<>());

    private static final ClassDesc CD_Module = ClassDesc.of("java.lang.Module");
    private static final ClassDesc CD_SecurityException = ClassDesc.of("java.lang.SecurityException");
    private static final ClassDesc CD_FrameworkClass = ClassDesc.ofDescriptor(FRAMEWORK_CLASS.descriptorString());

    // Cache: Class -> Specific Full Privilege Lookup (The one with PRIVATE bit)
    private static final ClassValue<Lookup> PER_CLASS_CACHE = new ClassValue<>() {
        @Override
        protected Lookup computeValue(Class<?> type) {
            return resolveFullPrivilegeLookup(type);
        }
    };

    /**
     * Entry Point: Gets the full privilege lookup for any class. Only works if the package is open to this library.
     */
    static Lookup lookupFor(Class<?> targetClass) {
        return PER_CLASS_CACHE.get(targetClass);
    }

    private static Lookup resolveFullPrivilegeLookup(Class<?> targetClass) {
        Module targetModule = targetClass.getModule();
        String packageName = targetClass.getPackageName();

        // No class generation if this module
        if (targetModule == THIS_MODULE) {
            try {
                return MethodHandles.privateLookupIn(targetClass, MethodHandles.lookup());
            } catch (IllegalAccessException e) {
                // Should never happen as this is this module
                throw new Error(e);
            }
        }

        // MethodHandles.privateLookupIn requires that the caller (THIS_MODULE)
        // reads the target module. Since the target might be a dynamic plugin
        // or a layer not known at compile time, we must ensure readability now.
        if (!THIS_MODULE.canRead(targetModule)) {
            THIS_MODULE.addReads(targetModule);
        }

        // Make sure the package is actually open to us
        if (!targetModule.isOpen(packageName, THIS_MODULE)) {
            throw new IllegalAccessError("Package " + packageName + " in module " + targetModule.getName() + " is not open to " + THIS_MODULE.getName());
        }

        // We only generate 1 spy per module, get it from the cache
        Lookup masterLookup = PER_MODULE_CACHE.computeIfAbsent(targetModule, _ -> {
            return injectHandshakeSpy(targetClass);
        });

        // Teleport to the specific class
        try {
            return MethodHandles.privateLookupIn(targetClass, masterLookup);
        } catch (IllegalAccessException e) {
            // This is strange, access has been revoked in the mean time
            throw new RuntimeException("Access revoked for " + targetClass.getName(), e);
        }
    }

    private static Lookup injectHandshakeSpy(Class<?> anchorClass) {
        try {
            // MethodHandles.privateLookupIn() drops the MODULE bit when crossing modules.
            // This means we cannot use defineHiddenClass.
            // However, the resulting 'packageLookup' has PACKAGE access, which is sufficient
            // for defineClass().
            Lookup packageLookup = MethodHandles.privateLookupIn(anchorClass, MethodHandles.lookup());

            // Generate a unique name.
            String spyInternalName = anchorClass.getPackageName().replace('.', '/') + "/PackedHandshake_" + UUID.randomUUID().toString().replace("-", "");

            // Generate the bytecode.
            byte[] bytes = generateIdentityCheckSpy(spyInternalName);

            // Define the class into the user's module.
            Class<?> spyClass = packageLookup.defineClass(bytes);

            // Invoke the 'get' method.
            // We pass our lookup as the token. The bytecode verifies this token comes
            // from this module
            return (Lookup) spyClass.getMethod("get", Lookup.class).invoke(null, MethodHandles.lookup());
        } catch (Exception e) {
            throw new RuntimeException("Injection failed for module " + anchorClass.getModule().getName(), e);
        }
    }

    private static byte[] generateIdentityCheckSpy(String internalName) {
        // Method Signature: public static Lookup get(Lookup token)
        MethodTypeDesc methodSig = MethodTypeDesc.of(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup);

        return ClassFile.of().build(ClassDesc.ofInternalName(internalName), cb -> {
            cb.withFlags(AccessFlag.PUBLIC, AccessFlag.FINAL);

            cb.withMethod("get", methodSig, AccessFlag.PUBLIC.mask() | AccessFlag.STATIC.mask(), mb -> mb.withCode(code -> {

                // Load Token (arg0)
                code.aload(0);

                // Extract Module: token.lookupClass().getModule()
                code.invokevirtual(CD_MethodHandles_Lookup, "lookupClass", MethodTypeDesc.of(CD_Class));
                code.invokevirtual(CD_Class, "getModule", MethodTypeDesc.of(CD_Module));

                // Load Framework Module:
                code.ldc(CD_FrameworkClass);
                code.invokevirtual(CD_Class, "getModule", MethodTypeDesc.of(CD_Module));

                // 4. Compare References (tokenModule != frameworkModule)
                java.lang.classfile.Label failLabel = code.newLabel();
                code.if_acmpne(failLabel);

                // SUCCESS -> return lookup object
                code.invokestatic(CD_MethodHandles, "lookup", MethodTypeDesc.of(CD_MethodHandles_Lookup));
                code.areturn();

                // FAILURE -> Throw SecurityException
                code.labelBinding(failLabel);
                code.new_(CD_SecurityException);
                code.dup();
                code.invokespecial(CD_SecurityException, "<init>", MethodTypeDesc.ofDescriptor("()V"));
                code.athrow();
            }));
        });
    }
}
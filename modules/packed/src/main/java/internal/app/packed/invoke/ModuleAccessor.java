package internal.app.packed.invoke;

import static java.lang.constant.ConstantDescs.CD_Class;
import static java.lang.constant.ConstantDescs.CD_MethodHandles;
import static java.lang.constant.ConstantDescs.CD_MethodHandles_Lookup;

import java.lang.classfile.ClassFile;
import java.lang.constant.ClassDesc;
import java.lang.constant.MethodTypeDesc;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.reflect.AccessFlag;
import java.util.Collections;
import java.util.Map;
import java.util.UUID;
import java.util.WeakHashMap;

import app.packed.extension.Extension; // The class we verify against

/**
 * Support class for generating hidden classes and accessing internal logic in foreign modules.
 * <p>
 * This mechanism uses a "Handshake Spy". It injects a named class into the target module that demands proof of identity
 * (a Lookup from THIS framework) before surrendering a Lookup with MODULE access.
 */
final class ModuleAccessor {

    // The framework module to validate against
    private static final Module THIS_MODULE = ModuleAccessor.class.getModule();

    // The specific class in our framework that serves as the "Identity Anchor".
    // The generated bytecode will perform: Extension.class.getModule()
    private static final Class<?> FRAMEWORK_ANCHOR = Extension.class;

    // Cache: Module -> Master Lookup (The one with MODULE bit)
    // WeakHashMap allows the Module to be unloaded if the ClassLoader dies.
    private static final Map<Module, Lookup> PER_MODULE_CACHE = Collections.synchronizedMap(new WeakHashMap<>());

    // --- Descriptors (Cached for performance and readability) ---
    // CD_Class is imported from java.lang.constant.ConstantDescs
    private static final ClassDesc CD_Module = ClassDesc.of("java.lang.Module");
    private static final ClassDesc CD_SecurityException = ClassDesc.of("java.lang.SecurityException");

    // The framework class we verify against (app.packed.extension.Extension)
    private static final ClassDesc CD_FrameworkAnchor = ClassDesc.ofDescriptor(FRAMEWORK_ANCHOR.descriptorString());

    // Cache: Class -> Specific Full Privilege Lookup (The one with PRIVATE bit)
    private static final ClassValue<Lookup> PER_CLASS_CACHE = new ClassValue<>() {
        @Override
        protected Lookup computeValue(Class<?> type) {
            return resolveFullPrivilegeLookup(type);
        }
    };

    /**
     * Entry Point: Gets the full privilege lookup for any class. Only works if the package is open to this library.
     */
    static Lookup lookupFor(Class<?> targetClass) {
        return PER_CLASS_CACHE.get(targetClass);
    }

    private static Lookup resolveFullPrivilegeLookup(Class<?> targetClass) {
        Module targetModule = targetClass.getModule();
        String packageName = targetClass.getPackageName();

        // 0. no spy needed for packed
        if (targetModule == THIS_MODULE) {
            try {
                return MethodHandles.privateLookupIn(targetClass, MethodHandles.lookup());
            } catch (IllegalAccessException e) {
                // Should never happen as this is this module
                throw new Error(e);
            }
        }

        // 1. Security Check: Is the specific package open to us?
        if (!targetModule.isOpen(packageName, THIS_MODULE)) {
            throw new IllegalAccessError("Package " + packageName + " in module " + targetModule.getName() + " is not open to " + THIS_MODULE.getName());
        }

        // 2. Get the Master Lookup for the module (Cached)
        Lookup masterLookup = PER_MODULE_CACHE.computeIfAbsent(targetModule, _ -> {
            return injectHandshakeSpy(targetClass);
        });

        // 3. Teleport the Master Lookup to the specific class.
        // This adds 'PRIVATE' access while keeping the 'MODULE' bit derived from the master.
        try {
            return MethodHandles.privateLookupIn(targetClass, masterLookup);
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Access revoked for " + targetClass.getName(), e);
        }
    }

    private static Lookup injectHandshakeSpy(Class<?> anchorClass) {
        try {
            // A. Get PACKAGE access.
            // MethodHandles.privateLookupIn() drops the MODULE bit when crossing modules.
            // However, the resulting 'packageLookup' has PACKAGE access, which is sufficient
            // for defineClass() (but not defineHiddenClass).
            Lookup packageLookup = MethodHandles.privateLookupIn(anchorClass, MethodHandles.lookup());

            // B. Generate a unique name.
            // Although we define a named class, the UUID makes it statistically impossible
            // for an attacker to guess the name for Class.forName() before we consume it.
            String spyInternalName = anchorClass.getPackageName().replace('.', '/') + "/PackedHandshake_" + UUID.randomUUID().toString().replace("-", "");

            // C. Generate Bytecode.
            byte[] bytes = generateIdentityCheckSpy(spyInternalName);

            // D. Define the class into the user's module.
            Class<?> spyClass = packageLookup.defineClass(bytes);

            // E. Invoke the 'get' method.
            // We pass *our* lookup as the token. The bytecode verifies this token comes
            // from the same module as Extension.class.
            Lookup myToken = MethodHandles.lookup();

            return (Lookup) spyClass.getMethod("get", Lookup.class).invoke(null, myToken);
        } catch (Exception e) {
            throw new RuntimeException("Injection failed for module " + anchorClass.getModule().getName(), e);
        }
    }

    private static byte[] generateIdentityCheckSpy(String internalName) {
        // Method Signature: public static Lookup get(Lookup token)
        MethodTypeDesc methodSig = MethodTypeDesc.of(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup);

        return ClassFile.of().build(ClassDesc.ofInternalName(internalName), cb -> {
            cb.withFlags(AccessFlag.PUBLIC, AccessFlag.FINAL);

            cb.withMethod("get", methodSig, AccessFlag.PUBLIC.mask() | AccessFlag.STATIC.mask(), mb -> mb.withCode(code -> {

                // 1. Load Token (arg0)
                code.aload(0);

                // 2. Extract Module: token.lookupClass().getModule()
                code.invokevirtual(CD_MethodHandles_Lookup, "lookupClass", MethodTypeDesc.of(CD_Class));
                code.invokevirtual(CD_Class, "getModule", MethodTypeDesc.of(CD_Module));

                // 3. Load Framework Module: Extension.class.getModule()
                code.ldc(CD_FrameworkAnchor);
                code.invokevirtual(CD_Class, "getModule", MethodTypeDesc.of(CD_Module));

                // 4. Compare References (tokenModule != frameworkModule)
                java.lang.classfile.Label failLabel = code.newLabel();
                code.if_acmpne(failLabel);

                // --- SUCCESS ---
                // MethodHandles.lookup()
                code.invokestatic(CD_MethodHandles, "lookup", MethodTypeDesc.of(CD_MethodHandles_Lookup));
                code.areturn();

                // --- FAILURE ---
                code.labelBinding(failLabel);
                code.new_(CD_SecurityException);
                code.dup();
                code.invokespecial(CD_SecurityException, "<init>", MethodTypeDesc.ofDescriptor("()V"));
                code.athrow();
            }));
        });
    }
}